import subprocess
import sys
import os
import shutil
import re
import tempfile
from pathlib import Path

def get_current_version():
    """Read the current version from version.py file."""
    # Get the script directory and navigate to the parent directory
    script_dir = Path(__file__).parent
    project_root = script_dir.parent
    version_file = project_root / "src" / "version.py"
    
    if version_file.exists():
        content = version_file.read_text()
        # Extract version from __version__ = "x.y.z" line
        match = re.search(r'__version__\s*=\s*["\']([^"\']+)["\']', content)
        if match:
            return match.group(1)
    return "unknown"

def suggest_next_versions(current_version):
    """Suggest next version numbers based on current version."""
    if current_version == "unknown" or current_version == "dev":
        return "1.0.0 (major), 0.1.0 (minor), 0.0.1 (patch)"
    
    try:
        parts = current_version.split('.')
        if len(parts) >= 3:
            major, minor, patch = int(parts[0]), int(parts[1]), int(parts[2])
            return f"{major}.{minor}.{patch + 1} (patch), {major}.{minor + 1}.0 (minor), {major + 1}.0.0 (major)"
    except ValueError:
        pass
    
    return f"{current_version}.1 (patch), next.0.0 (minor), next.0.0 (major)"

def get_version():
    """Get version from user input or use 'dev' as default."""
    current_version = get_current_version()
    print(f"Latest known version: {current_version}")
    suggested_versions = suggest_next_versions(current_version)
    print(f"Suggested next versions: {suggested_versions}")
    version = input(f"Enter version (e.g., next version) or press Enter for 'dev': ").strip()
    
    if not version:
        return "dev"
    
    # Basic validation to warn about potentially old versions
    if version != "dev" and current_version != "unknown" and current_version != "dev":
        try:
            current_parts = current_version.split('.')
            new_parts = version.split('.')
            
            if len(current_parts) >= 3 and len(new_parts) >= 3:
                current_major, current_minor, current_patch = int(current_parts[0]), int(current_parts[1]), int(current_parts[2])
                new_major, new_minor, new_patch = int(new_parts[0]), int(new_parts[1]), int(new_parts[2])
                
                if (new_major < current_major or 
                    (new_major == current_major and new_minor < current_minor) or 
                    (new_major == current_major and new_minor == current_minor and new_patch <= current_patch)):
                    
                    print(f"⚠️  Warning: Version {version} appears to be older than or equal to the current version {current_version}")
                    confirm = input("Continue anyway? (y/N): ").strip().lower()
                    if confirm != 'y':
                        print("Build cancelled.")
                        sys.exit(0)
        except ValueError:
            print(f"⚠️  Warning: Non-standard version format: {version}")
    
    return version

def update_version_file(version):
    """Update the version.py file with the specified version."""
    version_file = Path("src/version.py")
    content = f'# This file is auto-generated by the build system\n__version__ = "{version}"\n'
    version_file.write_text(content)
    print(f"Updated version.py with version: {version}")

def update_installer_iss(version):
    """Update the installer.iss file with the version information."""
    installer_file = Path("installer.iss")
    if not installer_file.exists():
        print("Warning: installer.iss not found, skipping installer configuration update")
        return
    
    content = installer_file.read_text()
    dashed_version = version.replace('.', '-')
    
    # Format version for VersionInfoVersion (must be X.X.X.X format)
    version_info = format_version_for_inno(version)
    
    # Replace placeholders with actual version
    updated_content = content.replace('AppVersion=__APP_VERSION__', f'AppVersion={version}')
    updated_content = updated_content.replace('VersionInfoVersion=__APP_VERSION__', f'VersionInfoVersion={version_info}')
    updated_content = updated_content.replace('OutputBaseFilename=OverlordInstaller__APP_VERSION_DASHED__', f'OutputBaseFilename=OverlordInstaller{dashed_version}')
    
    # Write the updated content back
    installer_file.write_text(updated_content)
    print(f"Updated installer.iss with version: {version} (VersionInfoVersion: {version_info})")
    
    # Verify the replacement worked
    verify_content = installer_file.read_text()
    if '__APP_VERSION__' in verify_content:
        print("Warning: Some placeholders were not replaced in installer.iss")
        print("Current content around VersionInfoVersion:")
        lines = verify_content.split('\n')
        for i, line in enumerate(lines):
            if 'VersionInfoVersion' in line:
                print(f"  Line {i+1}: {line}")

def format_version_for_inno(version):
    """Format version string for Inno Setup VersionInfoVersion (must be X.X.X.X)."""
    if version == "dev":
        return "0.0.0.0"
    
    # Split version and pad with zeros if needed
    parts = version.split('.')
    
    # Ensure we have exactly 4 parts
    while len(parts) < 4:
        parts.append('0')
    
    # Take only first 4 parts and ensure they're numeric
    formatted_parts = []
    for i, part in enumerate(parts[:4]):
        try:
            # Convert to int to validate it's numeric, then back to string
            formatted_parts.append(str(int(part)))
        except ValueError:
            # If not numeric, use 0
            formatted_parts.append('0')
    
    return '.'.join(formatted_parts)

def install_dependencies():
    """Install required dependencies."""
    print("Installing dependencies...")
    dependencies = ["pyinstaller>=6.16", "pillow", "psutil"]
    
    for dep in dependencies:
        result = subprocess.run([sys.executable, "-m", "pip", "install", dep], 
                              capture_output=True, text=True)
        if result.returncode == 0:
            print(f"✓ {dep} installed successfully")
        else:
            print(f"✗ Failed to install {dep}: {result.stderr}")
            return False
    return True

def clean_dist_folder():
    """Clean out the dist folder before building."""
    dist_path = Path("dist")
    if dist_path.exists():
        print("Cleaning dist folder...")
        try:
            shutil.rmtree(dist_path)
            print("✓ Dist folder cleaned")
        except Exception as e:
            print(f"⚠️  Warning: Could not fully clean dist folder: {e}")
    
    # Recreate the dist folder
    dist_path.mkdir(exist_ok=True)
    print("✓ Dist folder ready")

def build_executable():
    """Build the executable using PyInstaller in a temporary directory."""
    print("\nBuilding executable...")
    
    # Get absolute paths for all resources
    current_dir = os.getcwd()
    favicon_path = os.path.join(current_dir, "images", "favicon.ico")
    overlord_logo_path = os.path.join(current_dir, "images", "overlordLogo.png")
    laserwolve_logo_path = os.path.join(current_dir, "images", "VineyardTechnologiesLogo.png")
    splash_screen_path = os.path.join(current_dir, "images", "splashScreen.png")
    main_script_path = os.path.join(current_dir, "src", "overlord.py")
    
    # Verify all required files exist
    required_files = [
        (favicon_path, "favicon.ico"),
        (overlord_logo_path, "overlordLogo.png"),
        (laserwolve_logo_path, "VineyardTechnologiesLogo.png"),
        (splash_screen_path, "splashScreen.png"),
        (main_script_path, "overlord.py")
    ]
    
    for file_path, file_name in required_files:
        if not os.path.exists(file_path):
            print(f"✗ Required file not found: {file_name} at {file_path}")
            return False
    
    # Create a temporary directory for PyInstaller output
    with tempfile.TemporaryDirectory() as temp_dir:
        temp_dist = os.path.join(temp_dir, "dist")
        temp_build = os.path.join(temp_dir, "build")
        spec_file = os.path.join(temp_dir, "overlord.spec")
        
        # Create a custom spec file to better handle tkinter
        spec_content = f'''# -*- mode: python ; coding: utf-8 -*-

import sys
import os

block_cipher = None

a = Analysis(
    ['{main_script_path.replace(os.sep, "/")}'],
    pathex=[],
    binaries=[],
    datas=[
        ('{favicon_path.replace(os.sep, "/")}', 'images'),
        ('{overlord_logo_path.replace(os.sep, "/")}', 'images'),
        ('{laserwolve_logo_path.replace(os.sep, "/")}', 'images'),
        ('{splash_screen_path.replace(os.sep, "/")}', 'images'),
    ],
    hiddenimports=[
        'tkinter',
        'tkinter.ttk',
        'tkinter.filedialog', 
        'tkinter.messagebox',
        'tkinter.font',
        'tkinter.constants',
        'PIL.ImageTk',
        'PIL.Image',
        'PIL._tkinter_finder',
        'OpenEXR',
        'Imath',
        'numpy',
        'psutil',
        'winreg',
        'threading',
        'json',
        'logging',
        'logging.handlers',
        'urllib.request',
        'tempfile',
        'glob',
        'argparse',
        'gc',
        'webbrowser',
        'subprocess',
        'shutil'
    ],
    hookspath=[],
    hooksconfig={{}},
    runtime_hooks=[],
    excludes=[],
    win_no_prefer_redirects=False,
    win_private_assemblies=False,
    cipher=block_cipher,
    noarchive=False,
)

# Filter out problematic or unnecessary modules
a.binaries = [x for x in a.binaries if not x[0].startswith('api-ms-win-')]

pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.zipfiles,
    a.datas,
    [],
    name='overlord',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon='{favicon_path.replace(os.sep, "/")}',
)
'''
        
        # Write the spec file
        with open(spec_file, 'w', encoding='utf-8') as f:
            f.write(spec_content)
        
        cmd = [
            sys.executable, "-m", "PyInstaller",
            "--distpath", temp_dist,
            "--workpath", temp_build,
            spec_file
        ]
        
        result = subprocess.run(cmd)
        if result.returncode != 0:
            print("✗ PyInstaller build failed.", file=sys.stderr)
            return False
        
        # Move the executable to the main dist folder for the installer to find
        temp_exe = os.path.join(temp_dist, "overlord.exe")
        final_exe = os.path.join("dist", "overlord.exe")
        
        if os.path.exists(temp_exe):
            # Ensure dist directory exists
            os.makedirs("dist", exist_ok=True)
            shutil.copy2(temp_exe, final_exe)
            print(f"✓ Executable temporarily placed at: {final_exe}")
        else:
            print("✗ Executable not found in temporary directory")
            return False
    
    print("✓ Executable built successfully (temporary files cleaned)")
    return True

def check_inno_setup():
    """Check if Inno Setup is installed and available."""
    try:
        result = subprocess.run(["iscc"], capture_output=True, text=True)
        return True
    except FileNotFoundError:
        return False

def install_inno_setup():
    """Install Inno Setup using chocolatey if available."""
    print("Inno Setup not found. Attempting to install via chocolatey...")
    try:
        result = subprocess.run(["choco", "install", "innosetup", "-y"], 
                              capture_output=True, text=True)
        if result.returncode == 0:
            print("✓ Inno Setup installed successfully")
            return True
        else:
            print("✗ Failed to install Inno Setup via chocolatey")
            return False
    except FileNotFoundError:
        print("✗ Chocolatey not found. Please install Inno Setup manually from https://jrsoftware.org/isinfo.php")
        return False

def build_installer():
    """Build the installer using Inno Setup."""
    print("\nBuilding installer...")
    
    if not check_inno_setup():
        if not install_inno_setup():
            print("Skipping installer creation due to missing Inno Setup")
            return False
    
    # Ensure dist directory exists
    os.makedirs("dist", exist_ok=True)
    
    result = subprocess.run(["iscc", "installer.iss"], cwd=os.getcwd())
    if result.returncode != 0:
        print("✗ Installer build failed.", file=sys.stderr)
        return False
    
    print("✓ Installer built successfully")
    return True

def cleanup():
    """Clean up build artifacts and temporary executable."""
    print("\nCleaning up build artifacts...")
    artifacts = ["build", "overlord.spec"]
    
    for artifact in artifacts:
        if os.path.exists(artifact):
            if os.path.isdir(artifact):
                shutil.rmtree(artifact)
            else:
                os.remove(artifact)
            print(f"✓ Removed {artifact}")
    
    # Remove the temporary executable from dist folder (keep only installer)
    temp_exe = os.path.join("dist", "overlord.exe")
    if os.path.exists(temp_exe):
        os.remove(temp_exe)
        print("✓ Removed temporary executable (keeping only installer)")

def cleanup_executable_only():
    """Remove just the temporary executable, preserving the installer."""
    temp_exe = os.path.join("dist", "overlord.exe")
    if os.path.exists(temp_exe):
        os.remove(temp_exe)
        print("✓ Removed temporary executable from dist folder")

def reset_installer_iss():
    """Reset installer.iss back to template state with placeholders."""
    installer_file = Path("installer.iss")
    if not installer_file.exists():
        return
    
    content = installer_file.read_text()
    
    # Reset version placeholders back to template format
    # This regex approach is more robust than simple string replacement
    import re
    
    # Reset AppVersion
    content = re.sub(r'AppVersion=.*', 'AppVersion=__APP_VERSION__', content)
    
    # Reset VersionInfoVersion  
    content = re.sub(r'VersionInfoVersion=.*', 'VersionInfoVersion=__APP_VERSION__', content)
    
    # Reset OutputBaseFilename
    content = re.sub(r'OutputBaseFilename=OverlordInstaller.*', 'OutputBaseFilename=OverlordInstaller__APP_VERSION_DASHED__', content)
    
    installer_file.write_text(content)
    print("✓ Reset installer.iss to template state")

def main():
    """Main build process."""
    print("=== Overlord Build Script ===")
    print("This script will build the installer locally.\n")
    
    # Clean dist folder first
    clean_dist_folder()
    
    # Get version from user
    version = get_version()
    
    # Update version files
    update_version_file(version)
    update_installer_iss(version)
    
    # Install dependencies
    if not install_dependencies():
        print("Failed to install dependencies. Exiting.")
        sys.exit(1)
    
    # Build executable (temporarily for installer creation)
    if not build_executable():
        print("Failed to build executable. Exiting.")
        sys.exit(1)
    
    # Build installer
    installer_success = build_installer()
    
    # Cleanup (this will remove the temporary executable and other artifacts)
    cleanup()
    
    # Reset installer.iss back to template state
    reset_installer_iss()
    
    # Summary
    print("\n=== Build Summary ===")
    print(f"Version: {version}")
    
    if installer_success:
        dashed_version = version.replace('.', '-')
        installer_name = f"OverlordInstaller{dashed_version}.exe"
        installer_path = os.path.join("dist", installer_name)
        if os.path.exists(installer_path):
            print(f"✓ Installer: dist/{installer_name}")
        else:
            print(f"⚠️  Installer expected at: dist/{installer_name} (file not found)")
    else:
        print("✗ Installer: Failed to create")
    
    print(f"\n✓ Dist folder contains only the installer (temporary executable removed)")
    print("Build process completed!")

if __name__ == "__main__":
    main()
