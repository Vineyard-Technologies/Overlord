var oContentMgr = App.getContentMgr();
var oScriptArgs = JSON.parse(App.scriptArgs[0]);
var nTotalNumberOfInstances = oScriptArgs['num_instances'];
var sMasterTemplatePath = oScriptArgs['template_path'];
var oScriptFileInfo = new DzFileInfo(getScriptFileName());
var sScriptPath = oScriptFileInfo.path();
var nInstanceNumber = App.instanceName();
var sOutputDirectory = oScriptArgs['image_output_dir'];
var oOutputDirectory = new DzDir(sOutputDirectory);
var aOutputDirectoryContents = oOutputDirectory.getFilesFromDir(['*.png'], false);
var sMostRecentRender;
var sMostRecentRenderDate;
var nMostRecentRenderMilliseconds = 0;
var sResultsDirectory = oScriptArgs['results_directory_path'];
var oResultsDirectory = new DzDir(sResultsDirectory);
var sSubjectFilepath = oScriptArgs['subject_file'];
var aAnimationFilepaths = oScriptArgs['animations'].toString().split(',');
var aPropAnimationFilepaths = oScriptArgs['prop_animations'].toString().split(',');
var aGearFilepaths = oScriptArgs['gear'].toString().split(',');
var aGearAnimationFilepaths = oScriptArgs['gear_animations'].toString().split(',');
var nDEGREES_IN_CIRCLE = 360;
var nFrameRate = oScriptArgs['frame_rate'];
var bRenderShadows = oScriptArgs['render_shadows'];
var nDAZ_TICKS = 4800;
var nTicksPerFrame = nDAZ_TICKS / nFrameRate;
var bOverwriteExistingImages = false;
var oRenderMgr;
var oIrayOptions;
var oRenderer;
var oEnvironmentOptionsPropertyGroups;
var oRenderOptions;
var oDrawGroundProperty;
var oEnvironmentModeProperty;
var oRoot;
var oShadowPlane;
var oSettings = new DzSettings();
var nCacheDbSizeThreshold = oScriptArgs['cache_db_size_threshold_gb'];
var sUserName = App.getAppDataPath().split('/')[2];
var sIrayServerDirectory = 'C:/Users/' + sUserName + '/AppData/Local/Overlord/IrayServer';
var sIrayServerDirectoryWindowsSlashes = sIrayServerDirectory.replace(/\//g, '\\');
var oIrayServerDirectory = new DzDir(sIrayServerDirectory);
var sCacheFolderPath = sIrayServerDirectory + '/cache';
var sScriptFileName = getScriptFileName();
var oScriptFileInfo = new DzFileInfo(sScriptFileName);
var oScriptDirectory = oScriptFileInfo.dir(); // DzDir object
var oIrayServerProcess = new DzProcess();
var oKillIrayServerAndCleanupProcess = new DzProcess();
var oImageMagickProcess = new DzProcess();
var aProcesses = [
	oIrayServerProcess,
	oKillIrayServerAndCleanupProcess,
	oImageMagickProcess
];
var nAUTODETECT_EXPORTER_PARAMETER = -1;
var sAddress = '127.0.0.1';
var sPort = 9090;
var sSecurity = 'http';
var sSecureProtocol = 'https';
var nIEND_CHUNK_POSITION = 8;
var nIEND_CHUNK_LENGTH = 4;
var bFlushLogBuffer = false;
var oHttpHelper = new DzHttpHelper();
var sAddress = '127.0.0.1';
var sPort = 9090;
var sSecurity = 'http';
var sSecureProtocol = 'https';

oHttpHelper.setConnectionMode(sSecurity);
oHttpHelper.setHost(sAddress);
oHttpHelper.setPort(sPort);
oHttpHelper.setPath('/');
oHttpHelper.setRequestMethod('GET');
oIrayServerProcess.name = 'Iray Server';
oKillIrayServerAndCleanupProcess.name = 'Kill Iray Server and Cleanup';
oImageMagickProcess.name = 'ImageMagick';
oIrayServerProcess.logging = false;
oKillIrayServerAndCleanupProcess.logging = true;
oImageMagickProcess.logging = true;
oIrayServerProcess.workingDirectory = sIrayServerDirectory;
oIrayServerProcess.arguments = [
	'C:/Program Files/NVIDIA Corporation/Iray Server/server/iray_server.exe',
	'--install-path',
	'C:/Program Files/NVIDIA Corporation/Iray Server',
	'--start-queue'
];
oKillIrayServerAndCleanupProcess.arguments = [
	'powershell.exe',
	'-Command',
	'Stop-Process -Name "iray_server" -Force -ErrorAction SilentlyContinue; ' +
	'Stop-Process -Name "iray_server_worker" -Force -ErrorAction SilentlyContinue; ' +
	'Remove-Item -Path "' + sIrayServerDirectory + '" -Recurse -Force -ErrorAction SilentlyContinue'
];
oSettings.setIntValue('Connection', 0);
oSettings.setStringValue('Server', sAddress);
oSettings.setBoolValue('Secure', sSecurity == sSecureProtocol);
oSettings.setIntValue('Port', sPort);
oSettings.setStringValue('Username', 'admin');
oSettings.setStringValue('Password', 'admin');

function wait(seconds) {

	sleep(seconds * 1000);
}

function log(sMessage) {

	App.log(sMessage);

	// bFlushLogBuffer should be true when debugging crashes and hangs
	// that might occur before a log message could be written.
	// Otherwise, leave it false to prevent excessive disk writes.
	if (bFlushLogBuffer) {

		App.flushLogBuffer();
	}
}
function startProcess(oProcess, sProcessName, bIsContinuous) {

		log('Launching ' + sProcessName + '...');

	if (oProcess.start()) {

		log(sProcessName + ' launched');

		if(bIsContinuous) return;

		while (oProcess.running) {

			log(sProcessName + ' is running...');

			processEvents();

			wait(1);
		}
		
		log(sProcessName + ' has finished.');

	} else {

		log('Could not start ' + sProcessName + '.');
	}
}

function killIrayServer() {

	log('Terminating Iray Server processes and cleaning up directory...');
	
	startProcess(oKillIrayServerAndCleanupProcess, 'Kill Iray Server and Cleanup', false);
	
	log('Iray Server processes terminated and directory cleaned.');

	while (new DzDir(sIrayServerDirectory).exists()) {

		log('Waiting for Iray Server directory to be fully removed: ' + sIrayServerDirectory);

		wait(1);	
	}
	log('Iray Server directory has been removed: ' + sIrayServerDirectory);		
}
// Kill Iray server if it's running, remove the server files, then restart it
function restartIrayServer() {

	killIrayServer();

	// Make an empty Iray Server directory if one doesn't exist
	if(!(new DzDir(sIrayServerDirectory).exists())) {

		log('Iray Server directory does not exist. Creating: ' + sIrayServerDirectory + '...');
		oIrayServerDirectory.mkdir(sIrayServerDirectory);
		log('Created Iray Server directory: ' + sIrayServerDirectory);

	} else {

		log('Iray Server directory already exists: ' + sIrayServerDirectory);
	}

	startProcess(oIrayServerProcess, 'Iray Server', true);

	// https://github.com/Vineyard-Technologies/Overlord/issues/31
	wait(5);

}
// Check if an image exists and isn't truncated
function isValidImage(sFilePath) {

	var oFileInfo = new DzFileInfo(sFilePath);

	if (!oFileInfo.exists()) {

		return false;
	}
	var oFile = new DzFile(sFilePath);
	var nFileSize = oFileInfo.size();


	oFile.open(DzFile.ReadOnly);

	oFile.seek(nFileSize - nIEND_CHUNK_POSITION);

	var aEndChunk = oFile.read(nIEND_CHUNK_LENGTH);

	oFile.close();

	var sEndChunk = aEndChunk.convertToString();

	log('Last chunk of PNG file: ' + sEndChunk);
	return sEndChunk === 'IEND';
}
// Obtain the desired name out of a filepath or filename.
function getName(sFileName) {
	return new DzFileInfo(sFileName).completeBaseName();
}
// Whenever filepath(s) are not specified, an array with a single,
// undefined object is passed. This function checks for that.
function thereAre(aArray) {
	return aArray[0] !== '';
}
// Set the Matte Parameter of a subject and its children.
function setMatte(oSubject, bBool) {

	var sIrayMatteLabel = 'Enable Iray Matte';

	oSubject.oMatteParameter = oSubject.findPropertyByLabel(sIrayMatteLabel);

	if (oSubject.oMatteParameter) {

		oSubject.oMatteParameter.setValue(bBool);
	}

	for (var nChildCounter = 0; nChildCounter != oSubject.aChildren.length; nChildCounter++) {

		var oChild = oSubject.aChildren[nChildCounter];

		oChild.oMatteParameter = oChild.findPropertyByLabel(sIrayMatteLabel);

		if (oChild.oMatteParameter) {

			oChild.oMatteParameter.setValue(bBool);
		}
	}
}
function renderCore(sSubjectName, sAnimationName, bIsGear, bIsShadow) {

	// These variables have to be determined when we start rendering
	oRenderMgr = App.getRenderMgr();
	oIrayOptions = oRenderMgr.getRenderElementObjects()[1];
	oRenderer = oRenderMgr.findRenderer('DzIrayRenderer');
	oRenderer.setBridgeConfiguration(oSettings);
	oEnvironmentOptionsPropertyGroups = oRenderMgr.getRenderElementObjects()[3].getPropertyGroups();
	oRenderOptions = oRenderMgr.getRenderOptions();
	oDrawGroundProperty = oEnvironmentOptionsPropertyGroups.findProperty('Draw Ground');
	oEnvironmentModeProperty = oEnvironmentOptionsPropertyGroups.findProperty('Environment Mode');
	oRoot = Scene.findNodeByLabel('root');
	oRootYRotControl = oRoot.getYRotControl();
	oShadowPlane = Scene.findNodeByLabel('shadowPlane');
	var oCamera = Scene.findCameraByLabel('isometricCamera');

	// Read the subject's JSON to see how many angles it has
	{
		var oSubjectFile = new DzFile(sSubjectFilepath);
		var nAngles = 16;

		oSubjectFile.open(DzFile.ReadOnly);

		var nAnglesFromJson = JSON.parse(oSubjectFile.read()).asset_info.angles;

		oSubjectFile.close();

		if (nAnglesFromJson) nAngles = nAnglesFromJson;
		else App.warning('Number of angles not found in the JSON for ' + sSubjectFilepath +
			'. Using default of value of ' + nAngles + ' angles.');

		var nDegrees = nDEGREES_IN_CIRCLE / nAngles;
	}
	
	// Read the animation's JSON to see how many frames it has
	if (sAnimationName != 'static') {
		// https://github.com/Vineyard-Technologies/Overlord/discussions/4
		var oAnimationFile = new DzFile(sAnimationFilepath);

		oAnimationFile.open(DzFile.ReadOnly);
		var oAnimationsJson = JSON.parse(oAnimationFile.read()).scene.animations;
		oAnimationFile.close();

		for (var nJsonCounter = 0; nJsonCounter < oAnimationsJson.length; nJsonCounter++) {
			var nNumberOfFrames = oAnimationsJson[nJsonCounter].keys.length;

			if (nNumberOfFrames > 1) {
				// Subtract 1 here to make it 0-based
				Scene.setAnimRange(DzTimeRange(0, (nNumberOfFrames - 1) * nTicksPerFrame));

				break;
			}
		}
	} else Scene.setAnimRange(DzTimeRange(0, 0));

	if (bIsGear) {
		// Add the gear to the canvas.
		oIrayOptions.addNodeToNodeList('visibleNodes', oGear);

		// Add all gear children to the canvas as well.
		for (var nGearChildrenCounter = 0; nGearChildrenCounter != aGearChildren.length; nGearChildrenCounter++)
			oIrayOptions.addNodeToNodeList('visibleNodes', aGearChildren[nGearChildrenCounter]);
	}

	// Add the subject as a child to the root
	oRoot.addNodeChild(oSubject, true);

	// variables that have to be determined when we start rendering
	var nFramesTotal = Scene.getPlayRange().end / nTicksPerFrame;

	// Loop through each angle...
	for (var nAngle = 0; nAngle != nDEGREES_IN_CIRCLE; nAngle = nAngle + nDegrees) {

		var nOutputAngle = 90 - nAngle;

		if (nOutputAngle <= -180) {

			nOutputAngle += 360;
		}

		// Loop through each frame...
		frameLoop: for (var nFrame = 0; nFrame <= nFramesTotal; nFrame++) {

			// Check if the current Daz instance should render this frame.
			if ((nFrame - (nInstanceNumber - 1)) % nTotalNumberOfInstances != 0) {

				continue frameLoop;
			}

			var sFinalName = sSubjectName + (bIsShadow ? '_shadow-' : '-') + sAnimationName + '_' + nOutputAngle + '-' + ('000' + nFrame).slice(-3);
			var sImageFileOutputPath = sOutputDirectory + '/' + sFinalName + '.png';

			if (isValidImage(sImageFileOutputPath)) {

				log(sImageFileOutputPath + ' already exists. Skipping this frame.');

				continue frameLoop;
			} else {

				log(sImageFileOutputPath + ' does not exist. Rendering this frame.');

			}

			log('Setting frame to ' + nFrame);
			Scene.setFrame(nFrame);
			// Do this every frame, or else it will interpolate.
			log('Setting root Y rotation to ' + nAngle);
			oRootYRotControl.setValue(nAngle);

			if (bIsShadow) {
				// Scene Only
				oEnvironmentModeProperty.setValue(3);
				oDrawGroundProperty.setValue(true);
				oShadowPlane.setVisible(true);
				oIrayOptions.renderToCanvases = false;
				if (bIsGear) setMatte(oSubject, true);
			} else {
				// Sun-Sky Only
				oEnvironmentModeProperty.setValue(2);
				oDrawGroundProperty.setValue(false);
				oShadowPlane.setVisible(false);
				setMatte(oSubject, false);
				if (bIsGear) oIrayOptions.renderToCanvases = true;
			}
			// Wait for everything else to finish first, specifically the mesh smoother
			// while (backgroundProgressIsActive()) processEvents();

			var oCacheDbFile = new DzFileInfo(sCacheFolderPath + '/cache.db');
			var nCacheDbSize = oCacheDbFile.size();

			log('Current cache database size: ' + nCacheDbSize / (1024 * 1024 * 1024) + 'GBs.');

			// Check if cache.db is over the threshold (10GBs)
			if (nCacheDbSize > nCacheDbSizeThreshold * 1024 * 1024 * 1024) {

				log('Cache database size is over the threshold of ' + nCacheDbSizeThreshold + 'GBs. Restarting Iray Server...');
				restartIrayServer();
			}

			var sHttpRequestError = "initial"; // Start with error to enter the loop
			var nHttpAttempts = 0;
			var nMAX_HTTP_ATTEMPTS = 5;

			App.log('Checking if the Iray Server is online...');

			while (sHttpRequestError) {

				App.log('Sending HTTP request to Iray Server...');
				// This returns a truthy byteArray regardless of the status
				// of the server, so we're not using it to check server status.
				oHttpHelper.doSynchronousRequest();

				App.log('HTTP request sent. Capturing errors (if any)...');
				// This returns an empty string upon successful connection,
				// otherwise it returns the error as a string.
				sHttpRequestError = oHttpHelper.getError();

				if (sHttpRequestError) {
					nHttpAttempts++;
					App.log('HTTP request error (attempt ' + nHttpAttempts + '/' + nMAX_HTTP_ATTEMPTS + '): ' + sHttpRequestError);

					if (nHttpAttempts >= nMAX_HTTP_ATTEMPTS) {

						App.log('Maximum HTTP attempts reached. Restarting Iray Server...');

						restartIrayServer();

						nHttpAttempts = 0;
												
					} else {

						wait(1);
					}
				}
				else {
					App.log('HTTP request successful - Iray Server is online.');
				}

			}

			var oResponse;

			do {

				log('Sending render to Iray Server...');

				// here was the original location

				var nRENDER_PRIORITY = 0;
				// This method is undocumented, but used in an example.
				try {
					App.flushLogBuffer();
					oResponse = oRenderer.exportRenderToBridgeQueue(sFinalName, 'png', oCamera, oRenderOptions, nRENDER_PRIORITY);
					log('Render sent to Iray Server.');
				} catch (e) {
					log('Exception caught while sending render to Iray Server: ' + e);
					oResponse = { errorMsg: e.toString() };
				}

				if(oResponse['errorMsg']) {

					// Errors are already written to the console
					
					wait(1);
				}
				 
			} while (oResponse['errorMsg']);

			wait(2); // Plausible minimum render time

			var nImageMagickAttempts = 0;
			var nMAX_IMAGEMAGICK_ATTEMPTS = 10;
			var sImageFileResultsPath = sResultsDirectory + '/' + sFinalName + '/' + sFinalName + (bIsGear && !bIsShadow ? '-GearCanvas-Beauty.exr' : '-Beauty.png');
			var oImageFileResultsPathFileInfo = new DzFileInfo(sImageFileResultsPath);

			// ImageMagick
			do {

				wait(1);
				
				nImageMagickAttempts++;
				log('ImageMagick attempt ' + nImageMagickAttempts + '/' + nMAX_IMAGEMAGICK_ATTEMPTS);

				oImageMagickProcess.arguments = [
					'powershell.exe',
					'-Command',
					'magick "' + sImageFileResultsPath + '" ' +
					// Only use -auto-level on EXR files.
					// We're still using this command to move and rename PNGs because
					// We were neither the results DzDir or the output DzDir were letting
					// us use move() from one directory to the other.
					(oImageFileResultsPathFileInfo.suffix() == 'exr' ? '-auto-level ' : '') +
					'"' + sImageFileOutputPath + '"'
				];

				// https://github.com/Vineyard-Technologies/Overlord/discussions/28
				log('ImageMagick arguments: ' + oImageMagickProcess.arguments.join(' '));	
				startProcess(oImageMagickProcess, 'ImageMagick', false);

				// If we've reached max attempts and still no valid image, restart this frame
				if (nImageMagickAttempts >= nMAX_IMAGEMAGICK_ATTEMPTS && !isValidImage(sImageFileOutputPath)) {
					log('Maximum ImageMagick attempts reached for frame ' + nFrame + '. Restarting this frame...');
					nFrame--;
					continue frameLoop;
				}

			} while (!isValidImage(sImageFileOutputPath));
			log('File has appeared in output folder.');
		}
	}
	if (bRenderShadows) {
		if (!bIsShadow) renderCore(sSubjectName, sAnimationName, bIsGear, true);
	}
}

App.enableMultiThreading(true);

// Setup process logging for all processes
for (var nProcessCounter = 0; nProcessCounter < aProcesses.length; nProcessCounter++) {

	var oCurrentProcess = aProcesses[nProcessCounter];
	
	if (oCurrentProcess.logging) {

		log('Logging for ' + oCurrentProcess.name + ' is enabled. Connecting to stdout and stderr...');
		oCurrentProcess.communication = DzProcess.Stdin | DzProcess.Stdout | DzProcess.Stderr;
		
		// Create closure to capture the process name for logging
		(function(processName, process) {
			connect(process, 'readyReadStdout()', function() {
				if(process.readStdout()) log(processName + ' stdout: ' + process.readStdout());
			});
			connect(process, 'readyReadStderr()', function() {
				if(process.readStderr()) log(processName + ' stderr: ' + process.readStderr());
			});
		})(oCurrentProcess.name, oCurrentProcess);

		log('Logging for ' + oCurrentProcess.name + ' is now live.');
	} else {
		log('Logging for ' + oCurrentProcess.name + ' is disabled.');
	}
}

// Clean up any previous Iray Server instance, and start with a clean slate
restartIrayServer();

// Find the most recent render in the output directory

for (var i = 0; i != aFiles.length; i++) {
	
	var sThisRender = aFiles[i];
	var oThisRenderFileInfo = new DzFileInfo(sThisRender);
	var oThisRenderDate = oThisRenderFileInfo.lastModified();
	var sThisRenderDate = oThisRenderDate.toString();
	var nThisRenderDateMilliseconds = oThisRenderDate.getTime();
	
	if (nThisRenderDateMilliseconds > nMostRecentRenderMilliseconds) {
	
		nMostRecentRenderMilliseconds = nThisRenderDateMilliseconds;
		
		sMostRecentRender = aFiles[i];
		
		sMostRecentRenderDate = sThisRenderDate;
	}
}

print('The most recent render is ' + sMostRecentRender + ', which was created at ' +sMostRecentRenderDate);

var oMostRecentRenderFileInfo = new DzFileInfo(sMostRecentRender);
var sMostRecentRenderBaseName = oMostRecentRenderFileInfo.completeBaseName();
var sMostRecentRenderSubjectName = sMostRecentRenderBaseName.split('_').shift();
var bMostRecentRenderIsGear = sMostRecentRenderBaseName.search('_gear_') !== -1;
var sMostRecentRenderGearName = bMostRecentRenderIsGear ? sMostRecentRenderBaseName.split('_')[1] : '';
var bMostRecentRenderIsShadow = sMostRecentRenderBaseName.search('_shadow-') !== -1;
var sMostRecentRenderAnimationName = sMostRecentRenderBaseName.split('-').shift().split('_').pop();
var sMostRecentRenderAngle = sMostRecentRenderBaseName.split('_').pop().split('-').shift();
var sMostRecentRenderFrame = sMostRecentRenderBaseName.split('-').pop();

// Make the output directory if it doesn't exist
if(!oOutputDirectory.exists()) {

	log('Output directory does not exist. Creating: ' + sOutputDirectory + '...');
	oOutputDirectory.mkdir(sOutputDirectory);
	log('Created output directory: ' + sOutputDirectory);

} else {

	log('Output directory already exists: ' + sOutputDirectory);
}


var sSubjectName = getName(sSubjectFilepath);

if (thereAre(aAnimationFilepaths)) {
	for (var nAnimationFilepathsCounter = 0; nAnimationFilepathsCounter != aAnimationFilepaths.length; nAnimationFilepathsCounter++) {
		var sAnimationFilepath = aAnimationFilepaths[nAnimationFilepathsCounter];
		var sAnimationName = getName(sAnimationFilepath);

		// Start with a blank scene
		oContentMgr.openFile(sMasterTemplatePath, false);

		// Merge in the subject
		oContentMgr.openFile(sSubjectFilepath, true);

		var oSubject = Scene.findNodeByLabel('subject');
		
		/*
		We have to turn off limits for the subject and its children
		because the perferences parameter 'When importing a Pose/Shaping file that exceeds limits :'
		(under the 'Content' tab) is _not_ set to 'Always turn limits off'
		on headless runs and fresh Daz Studio installs.
		*/
		oSubject.aPropertyList = oSubject.getPropertyList();

		// Turn off limits for all the subject's properties
		for (var nPropertyCounter = 0; nPropertyCounter != oSubject.aPropertyList.length; nPropertyCounter++) {

			var oProperty = oSubject.aPropertyList[nPropertyCounter];

			turnLimitOff(oProperty);
		}

		// We use the subject's children to turn off their matte parameter,
		// and to turn off their limits.
		oSubject.aChildren = oSubject.getNodeChildren(true);

		// Give the subject's children a property containing their property list
		for (var nChildCounter = 0; nChildCounter != oSubject.aChildren.length; nChildCounter++) {

			var oChild = oSubject.aChildren[nChildCounter];

			oChild.aPropertyList = oChild.getPropertyList();

			// Loop through that property list, turning off limits
			for (var nPropertyCounter = 0; nPropertyCounter != oChild.aPropertyList.length; nPropertyCounter++) {

				var oProperty = oChild.aPropertyList[nPropertyCounter];

				turnLimitOff(oProperty);
			}
		}

		// Limits are called 'limits' in the UI, and 'clamps' in Daz Script
		function turnLimitOff(oProperty) {

			// If this property has a 'setIsClamped' function...
			if (!!oProperty.setIsClamped) {

				oProperty.setIsClamped(false);
			}
		}

		oContentMgr.openFile(sAnimationFilepath, true);

		if (thereAre(aPropAnimationFilepaths)) {
			for (var nPropAnimationCounter = 0; nPropAnimationCounter != aPropAnimationFilepaths.length; nPropAnimationCounter++) {
				
				var sPropAnimationFilepath = aPropAnimationFilepaths[nPropAnimationCounter];
				var sPropAnimationFileName = getName(sPropAnimationFilepath);
				var aPropAnimationProperties = sPropAnimationFileName.split('-');
				var sAnimationOfPropAnimation = aPropAnimationProperties.shift();
				var sPropOfPropAnimation = aPropAnimationProperties.pop();

				if (sAnimationName == sAnimationOfPropAnimation) {
					
					var oProp = Scene.findNodeByLabel(sPropOfPropAnimation);

					oSubject.select(false);
					oProp.select(true);

					oContentMgr.openFile(sPropAnimationFilepath, true);

					oProp.select(false);
					oSubject.select(true);
				} else continue;
			}
		}

		if (thereAre(aGearFilepaths)) {
			for (var nGearCounter = 0; nGearCounter != aGearFilepaths.length; nGearCounter++) {
				var sGearFilepath = aGearFilepaths[nGearCounter];

				oContentMgr.openFile(sGearFilepath, true);

				var sGearName = getName(sGearFilepath);
				var oGear = Scene.findNodeByLabel('gear');

				var aGearChildren = oGear.getNodeChildren(false);

				renderCore(sSubjectName + '_' + sGearName + '_gear', sAnimationName, true, false);

				Scene.removeNode(oGear);
			}
		} else renderCore(sSubjectName, sAnimationName, false, false);
	}
} else {
	oContentMgr.openFile(sMasterTemplatePath, false);

	oContentMgr.openFile(sSubjectFilepath, true);

	var oSubject = Scene.findNodeByLabel('subject');

	renderCore(sSubjectName, 'static', false, false);
}

log('Final cleanup: stopping Iray Server...');

killIrayServer();

App.delayedExit();